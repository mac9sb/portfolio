---
title: The Problem FLUENT-GEN Solves
date: January 18, 2025
---

FLUENT-GEN is a Swift macro package that automatically generates Fluent ORM model classes from simple domain model structs. This tool addresses a fundamental pain point in Swift backend development: the repetitive and error-prone process of writing database model boilerplate.

## The Problem: ORM Boilerplate Overload

When building Swift applications with Fluent ORM, developers face significant repetitive work. For every domain model, you need to create both a domain struct and a database model class with nearly identical properties.

### Traditional Approach (Painful)

```swift
// Domain model - what you actually want to work with
struct User {
    let id: UUID
    var name: String
    var email: String
    var createdAt: Date
}

// Database model - lots of boilerplate!
final class UserModel: Model {
    static let schema = "users"

    @ID(key: .id)
    var id: UUID?

    @Field(key: "name")
    var name: String

    @Field(key: "email")
    var email: String

    @Timestamp(key: "created_at", on: .create)
    var createdAt: Timestamp?

    init() {}

    init(id: UUID? = nil, name: String, email: String) {
        self.id = id
        self.name = name
        self.email = email
    }

    func toUser() -> User {
        User(id: id!, name: name, email: email, createdAt: createdAt!.date)
    }

    convenience init(from user: User) {
        self.init(id: user.id, name: user.name, email: user.email)
    }
}
```

This pattern repeats for every model in your application, leading to:
- **Code duplication** between domain and database models
- **Maintenance burden** when adding/changing fields
- **Error-prone conversions** between model types
- **Inconsistent naming** between domain and database layers

## The Solution: FLUENT-GEN Macro

FLUENT-GEN uses Swift macros to automatically generate the database model boilerplate from your domain models.

### Clean Domain-First Approach

```swift
// Just write your domain model with the @FluentModel macro
@FluentModel
public struct User: Codable, Identifiable, Sendable {
    public let id: UUID
    public var name: String
    public var email: String
    public var createdAt: Date
}

// FLUENT-GEN automatically generates:
// - UserModel class with all Fluent decorators
// - Proper field mappings (snake_case database columns)
// - Timestamp handling
// - Relationship support
// - Conversion methods between domain and database models
```

## How It Works

The `@FluentModel` macro analyzes your struct and generates a complete Fluent model class:

### Generated Output

```swift
// Automatically generated by FLUENT-GEN
final class UserModel: Model {
    static let schema = "users"

    @ID(key: .id)
    var id: UUID?

    @Field(key: "name")
    var name: String

    @Field(key: "email")
    var email: String

    @Timestamp(key: "created_at", on: .create)
    var createdAt: Date?

    @Timestamp(key: "updated_at", on: .update)
    var updatedAt: Date?

    init() {}

    init(id: UUID? = nil, name: String, email: String, createdAt: Date? = nil, updatedAt: Date? = nil) {
        self.id = id
        self.name = name
        self.email = email
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }
}

// Extension with conversion methods
extension UserModel {
    func toUser() -> User {
        User(id: id!, name: name, email: email, createdAt: createdAt!)
    }

    convenience init(from user: User) {
        self.init(id: user.id, name: user.name, email: user.email, createdAt: user.createdAt)
    }
}
```

## Key Features

### Automatic Field Mapping

FLUENT-GEN intelligently maps Swift property names to database column names:

```swift
@FluentModel
struct Product {
    let id: UUID
    var productName: String  // becomes "product_name" in database
    var isAvailable: Bool    // becomes "is_available" in database
    var createdAt: Date      // automatically handled as timestamp
}
```

### Relationship Support

The macro detects relationship properties and generates appropriate Fluent decorators:

```swift
@FluentModel
struct Order {
    let id: UUID
    var userID: UUID        // Becomes @Parent relationship
    var items: [String]     // Regular field
    var total: Decimal      // Regular field
}
```

### Enum Handling

FLUENT-GEN automatically detects and handles enums stored as strings:

```swift
enum OrderStatus: String, Codable {
    case pending, processing, shipped, delivered
}

@FluentModel
struct Order {
    let id: UUID
    var status: OrderStatus  // Stored as string in database
}
```

## Usage in Practice

### Service Layer Integration

```swift
actor UserService {
    let database: Database

    func createUser(_ user: User) async throws -> User {
        let model = UserModel(from: user)
        try await model.save(on: database)
        return model.toUser()
    }

    func getUser(id: UUID) async throws -> User? {
        guard let model = try await UserModel.find(id, on: database) else {
            return nil
        }
        return model.toUser()
    }
}
```

### Repository Pattern

```swift
protocol UserRepository {
    func save(_ user: User) async throws -> User
    func find(id: UUID) async throws -> User?
}

struct FluentUserRepository: UserRepository {
    let database: Database

    func save(_ user: User) async throws -> User {
        let model = UserModel(from: user)
        try await model.save(on: database)
        return model.toUser()
    }

    func find(id: UUID) async throws -> User? {
        try await UserModel.find(id, on: database)?.toUser()
    }
}
```

## Benefits

### Developer Experience
- **80% less boilerplate** code to write
- **Compile-time safety** - no runtime conversion errors
- **Consistent patterns** across your entire codebase
- **Easy refactoring** - change domain model, regeneration handles the rest

### Maintenance
- **Single source of truth** - domain model defines the schema
- **Automatic updates** - regenerate when you change models
- **Type safety** - compiler catches mismatches between domain and database models

### Performance
- **Zero runtime overhead** - all code generation happens at compile time
- **Optimized database queries** - generated models follow Fluent best practices
- **Memory efficient** - no unnecessary object conversions

## Integration with Build System

Add FLUENT-GEN to your project:

```swift
// Package.swift
dependencies: [
    .package(url: "https://github.com/mac9sb/fluent-gen", from: "1.0.0"),
]

// In your target
.target(
    name: "MyApp",
    dependencies: [
        .product(name: "FluentGen", package: "fluent-gen"),
    ]
)
```

Then just add `@FluentModel` to your domain structs and let the macro do the rest!

## Real-World Impact

FLUENT-GEN has been used in production applications including the GUEST-LIST venue management system, where it eliminated hundreds of lines of boilerplate code while maintaining type safety and performance.

This tool transforms Swift backend development from a tedious, error-prone process into a clean, maintainable experience focused on business logic rather than database plumbing.

## Learn More

For detailed documentation, advanced usage patterns, and examples:

[ðŸ”— View FLUENT-GEN on GitHub](https://github.com/mac9sb/fluent-gen)

FLUENT-GEN solves the fundamental problem of ORM boilerplate in Swift, allowing developers to focus on building great applications rather than writing repetitive database code.